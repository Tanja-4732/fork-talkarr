{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"talkarr","text":"<p>Talkarr is a *arr like program that allows you to download and manage videos from media.ccc.de.</p> <p>The idea was to create a program to download the favorites from the Fahrplan app to be able to watch them at home, for example when you were not able to be at the event.</p>"},{"location":"#roadmap-and-features","title":"Roadmap and Features","text":"<p>For a up-to-date list of features and the roadmap, please take a look at the README.md file on GitHub.</p> <p>You can find the Roadmap and Features here.</p>"},{"location":"deployment/","title":"How to deploy talkarr?","text":"<p>Right now, the only supported way for deploying is to use the Docker image. You can find information about deploying via Docker here.</p>"},{"location":"deployment/docker/","title":"Docker","text":"<p>This is the preferred method of deployment for this application. It helps to ensure that the application is running in a consistent environment, and that the application is isolated from the host system.</p> <p>Please change the values of the environment variables to match your environment.</p> <p>Warning</p> <p>Right now, the application is still in its early days. Some features might not work as expected or might not work at all. If you encounter any issues, please open an issue on the GitHub repository.</p> <p>Note</p> <p>There are multiple version tags available. For the latest stable image, use the <code>latest</code> tag. For the latest commit, use the <code>nightly</code> tag. For a specific version, use the version number as the tag, e.g. <code>v1.0.0</code>. You can find the releases here.</p>"},{"location":"deployment/docker/#deploying-via-docker-compose-recommended","title":"Deploying via Docker Compose (Recommended)","text":"<p>For more information about Docker Compose itself, please refer to the official documentation.</p> <p>For docker-compose, you can use this <code>.env</code> file as is and it should work:</p> <pre><code>POSTGRES_USER=talkarr\nPOSTGRES_PASSWORD=talkarr # Change this to a more secure password\nPOSTGRES_DB=talkarr\nPOSTGRES_HOST=localhost\nPOSTGRES_PORT=5432\n\nREDIS_HOST=redis\nREDIS_PORT=6379\nREDIS_PASSWORD=\n\n# postgresql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;database&gt;?schema=&lt;schema&gt;\nDATABASE_URL=\"postgresql://talkarr:talkarr@db:5432/talkarr?schema=public\"\n</code></pre> <p>This is the most basic docker-compose.yml file that you can use to deploy this application:</p> <pre><code>services:\n  db:\n    image: postgres:16-alpine\n    restart: unless-stopped\n    env_file:\n      - .env\n    volumes:\n      - ./data:/var/lib/postgresql/data # Store the data from postgres in \"./data\" directory\n    ports:\n      - \"5432:5432\"\n\n  redis:\n    image: valkey:8-alpine\n    restart: unless-stopped\n    ports:\n      - \"6379:6379\"\n\n  app:\n    image: ghcr.io/talkarr/talkarr:latest # from github\n    # image: talkarr/talkarr:latest # from docker hub\n    restart: unless-stopped\n    env_file:\n      - .env\n    ports:\n      - \"3232:3232\"\n    volumes:\n      - /path/to/your/media:/media # in theory, you can mount it wherever you like\n      - ./logs:/app/logs # Store the logs in \"./logs\" directory\n    depends_on:\n      - db\n      - redis\n</code></pre> <p>To run the application, you can use the following command:</p> <pre><code>docker-compose up -d\n\n# or\n\ndocker compose up -d\n</code></pre> <p>To stop the application, you can use the following command:</p> <pre><code>docker-compose down\n\n# or\n\ndocker compose down\n</code></pre> <p>To view the logs of the application, you can use the following command:</p> <pre><code>docker-compose logs -f app\n\n# or\n\ndocker compose logs -f app\n</code></pre> <p>And to update the application, you can use the following command:</p> <pre><code>docker-compose pull\ndocker-compose up -d\n\n# or\n\ndocker compose pull\ndocker compose up -d\n</code></pre>"},{"location":"deployment/docker/#deploying-via-docker","title":"Deploying via Docker","text":"<p>For normal Docker, you can use this <code>.env</code> file as is and it should work:</p> <pre><code>POSTGRES_USER=talkarr\nPOSTGRES_PASSWORD=talkarr # Change this to a more secure password\nPOSTGRES_DB=talkarr\nPOSTGRES_HOST=localhost\nPOSTGRES_PORT=5432\n\nREDIS_HOST=localhost\nREDIS_PORT=6379\nREDIS_PASSWORD=\n\n# postgresql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;database&gt;?schema=&lt;schema&gt;\nDATABASE_URL=\"postgresql://talkarr:talkarr@localhost:5432/talkarr?schema=public\"\n</code></pre> <p>If you prefer to deploy the application without using Docker Compose, you can use the following commands:</p> <pre><code>docker run -d --name db --env-file .env -v ./data:/var/lib/postgresql/data -p 5432:5432 postgres:16-alpine\ndocker run -d --name redis -p 6379:6379 valkey/valkey:8-alpine\ndocker run -d --name app --env-file .env -p 3232:3232 --link db:db --link redis:redis ghcr.io/talkarr/talkarr:latest\n</code></pre> <p>However, this method is not recommended as it is more difficult to manage the containers and their dependencies.</p>"},{"location":"deployment/docker/#deploying-to-with-existing-postgresql-and-redis-instances","title":"Deploying to with existing PostgreSQL and Redis instances","text":"<p>If you already have a PostgreSQL and Redis instance running, you can just set the environment variables accordingly:</p> <pre><code>POSTGRES_USER=talkarr\nPOSTGRES_PASSWORD=talkarr # Change this to a more secure password\nPOSTGRES_DB=talkarr\nPOSTGRES_HOST=localhost # Change this to the hostname of your PostgreSQL instance\nPOSTGRES_PORT=5432 # Change this to the port of your PostgreSQL instance\n\nREDIS_HOST=localhost # Change this to the hostname of your Redis instance\nREDIS_PORT=6379 # Change this to the port of your Redis instance\nREDIS_PASSWORD=\n\n# postgresql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;database&gt;?schema=&lt;schema&gt;\nDATABASE_URL=\"postgresql://talkarr:talkarr@localhost:5432/talkarr?schema=public\"\n</code></pre> <p>Then you can run the application using the following docker-compose file:</p> <pre><code>services:\n  app:\n    image: ghcr.io/talkarr/talkarr:latest\n    # image: talkarr/talkarr:latest\n    restart: unless-stopped\n    env_file:\n      - .env\n    ports:\n      - \"3232:3232\"\n    volumes:\n      - /path/to/your/media:/media # in theory, you can mount it wherever you like\n      - ./logs:/app/logs # Store the logs in \"./logs\" directory\n</code></pre> <p>Or you can run the application using the following command:</p> <pre><code>docker run -d --name app --env-file .env -p 3232:3232 ghcr.io/talkarr/talkarr:latest\n</code></pre>"},{"location":"development/notes/","title":"Development Notes","text":"<p>Here are some notes on the development of the project.</p>"},{"location":"development/notes/#mediacccde-api","title":"media.ccc.de API","text":"<p>For implementing the search, the api <code>https://api.media.ccc.de/public/events/search?q=&lt;SEARCH&gt;</code>will be used.</p> <p>You can find the \"full\" api documentation here: https://github.com/voc/voctoweb?tab=readme-ov-file#public-json-api</p>"},{"location":"development/notes/#wording","title":"Wording","text":"<p>Sometimes, the word \"event\" is used to refer to a talk. This is because the API from media.ccc.de is using the term \"event\", while I prefer to use \"Talk\".</p>"},{"location":"development/notes/#branding","title":"\"Branding\"","text":"<p>Our main colors are:</p> <ul> <li>Main: #9b69ff</li> <li>Secondary: #390a96</li> </ul>"},{"location":"development/notes/#why-are-there-so-many-ci-fix-commits","title":"Why are there so many CI fix commits?","text":"<p>Most of them are due to the fact that I am a bit new to Playwright (E2E-Testing) and also probably because I am doing things more complicated than they have to be.</p>"},{"location":"development/notes/#getting-the-minimum-engine-version","title":"Getting the minimum engine version","text":"<pre><code>npx ls-engines --mode actual --save\n</code></pre>"},{"location":"development/notes/#using-the-actionslabeler-action","title":"Using the actions/labeler action","text":"<p>The <code>actions/labeler</code> action is used to automatically add labels to pull requests. The configuration is stored in <code>.github/labeler.yml</code>.</p> <p>You can find the documentation here: actions/labeler</p>"},{"location":"infrastructure/technologies/","title":"Technologies used in the project","text":""},{"location":"infrastructure/technologies/#frontend-frameworks-and-libraries","title":"Frontend Frameworks and Libraries","text":"<ul> <li>Next.js - A React framework for building server-rendered applications</li> <li>React - A JavaScript library for building user interfaces</li> <li>Moment.js - A JavaScript date library for parsing, validating, manipulating, and formatting dates</li> </ul>"},{"location":"infrastructure/technologies/#ui-libraries","title":"UI Libraries","text":"<ul> <li>MUI - A popular React UI component library</li> <li>Notistack - A notification system for React</li> <li></li> </ul>"},{"location":"infrastructure/technologies/#state-management","title":"State Management","text":"<ul> <li>Zustand - A small, fast and scaleable bearbones state-management solution</li> </ul>"},{"location":"infrastructure/technologies/#persistent-data-storage","title":"Persistent Data Storage","text":"<ul> <li>Prisma - A modern database toolkit</li> <li>PostgreSQL - A powerful, open source object-relational database system</li> </ul>"},{"location":"infrastructure/technologies/#task-queue","title":"Task Queue","text":"<ul> <li>Bull - A Node.js job and message queue library</li> <li>Redis - An open source, in-memory data structure store, used as a database, cache, and message broker</li> </ul>"},{"location":"infrastructure/technologies/#deployment","title":"Deployment","text":"<ul> <li>Docker - A tool for building and running applications in containers</li> <li>Docker Compose - A tool for defining and running multi-container Docker applications</li> </ul>"},{"location":"infrastructure/technologies/#development","title":"Development","text":"<ul> <li>Node.js - A JavaScript runtime for building server-side applications</li> <li>TypeScript - A typed superset of JavaScript that compiles to plain JavaScript</li> <li>Nodemon - A utility that restarts the server when file changes are detected</li> <li>TS-Node - A TypeScript execution and REPL for Node.js</li> </ul>"},{"location":"infrastructure/technologies/#code-quality","title":"Code Quality","text":"<ul> <li>ESLint - A tool for identifying and reporting on patterns found in ECMAScript/JavaScript code</li> <li>Prettier - An opinionated code formatter (used as an ESLint plugin)</li> <li>TypeScript ESLint - An ESLint parser which leverages TypeScript to parse JavaScript</li> </ul>"},{"location":"infrastructure/technologies/#backend-and-api","title":"Backend and API","text":"<ul> <li>Express - A fast, unopinionated, minimalist web framework for Node.js</li> <li>OpenAPI - A way to describe RESTful APIs</li> <li>Swagger - A set of open-source tools built around the OpenAPI Specification</li> <li>openapi-typescript - A tool to generate TypeScript types from OpenAPI specifications</li> <li>openapi-fetch - A tool to generate API clients from OpenAPI specifications</li> <li>Typia - A tool to generate is-a type guards from TypeScript interfaces</li> <li>YouTube-DL-Exec - A node.js wrapper for youtube-dl / yt-dlp</li> <li>Winston - A logger for just about everything</li> </ul>"}]}